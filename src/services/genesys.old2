const logger = require('../utils/logger');
const { loadConnectionsConfig } = require('./token');
const WebSocket = require('ws');
const platformClient = require('purecloud-platform-client-v2');

// Store for client connections, notifications and websockets
const clientConnections = {};
const notifications = {};
const webSockets = {};

// Variabel til at holde styr på genoprettelser
const reconnectionAttempts = {};

async function connectToGenesys(connectionId, topics) {
    logger.info('Connecting to Genesys Cloud', { 
        connectionId, 
        topics 
    });

    // Hent forbindelseskonfiguration
    const configs = loadConnectionsConfig();
    const connection = configs.connections.find(c => c.id === connectionId);
    
    if (!connection) {
        throw new Error('Connection not found');
    }

    // Sørg for at emner altid er et array
    const topicsArray = Array.isArray(topics) ? topics : [topics];
    
    // Tjek om forbindelsen allerede eksisterer
    if (clientConnections[connectionId]) {
        // Tilføj nye emner til eksisterende forbindelse
        const existingTopics = clientConnections[connectionId].topics || [];
        const uniqueTopics = [...new Set([...existingTopics, ...topicsArray])];
        
        clientConnections[connectionId] = {
            ...clientConnections[connectionId],
            topics: uniqueTopics,
            timestamp: new Date()
        };
    } else {
        // Opret ny forbindelse
        clientConnections[connectionId] = {
            id: connectionId,
            name: connection.name,
            topics: topicsArray,
            region: connection.region,
            timestamp: new Date()
        };
    }

    // Initialiser notifikationsarray for denne forbindelse
    if (!notifications[connectionId]) {
        notifications[connectionId] = [];
    }

    // Hvis der allerede er en aktiv websocket, så luk den
    if (webSockets[connectionId]) {
        try {
            webSockets[connectionId].close();
        } catch (e) {
            logger.error('Error closing existing websocket', { error: e.message });
        }
    }

    try {
        // Opsæt Genesys Cloud API klient
        const client = platformClient.ApiClient.instance;
        
        // Konverter region string til det rigtige format
        let region = 'mypurecloud.com'; // Default US East
        
        if (connection.region === 'mypurecloud.de') {
            region = platformClient.PureCloudRegionHosts.eu_central_1;
        } else if (connection.region === 'mypurecloud.ie') {
            region = platformClient.PureCloudRegionHosts.eu_west_1;
        } else if (connection.region === 'mypurecloud.com.au') {
            region = platformClient.PureCloudRegionHosts.ap_southeast_2;
        } else if (connection.region === 'mypurecloud.jp') {
            region = platformClient.PureCloudRegionHosts.ap_northeast_1;
        } else {
            region = platformClient.PureCloudRegionHosts.us_east_1;
        }
        
        client.setEnvironment(region);
        
        // Autentificering
        if (connection.accessToken) {
            client.setAccessToken(connection.accessToken);
            logger.info('Testing authentication...', { connectionId });
            try {
                // Test API-kaldet med UsersApi
                const usersApi = new platformClient.UsersApi();
                const me = await usersApi.getUsersMe();
                logger.info('Authentication successful', { 
                    userId: me.id,
                    userName: me.name
                });
            } catch (error) {
                logger.error('Authentication failed', { 
                    error: error.message,
                    statusCode: error.statusCode
                });
                // Fortsæt med test data i dette tilfælde
                addTestNotification(connectionId);
                return Promise.resolve();
            }
        } else {
            // Hvis ingen accessToken, log en advarsel men fortsæt med test data
            logger.warn('No access token found for connection', { connectionId });
            addTestNotification(connectionId);
            return Promise.resolve();
        }
        
        // Opret en ny notifikationskanal
        const notificationsApi = new platformClient.NotificationsApi();
        try {
            // Hent tilgængelige emner
            const availableTopics = await notificationsApi.getNotificationsAvailabletopics();
            logger.info('Available topics', {
                count: availableTopics.entities.length,
                topics: availableTopics.entities.slice(0, 5).map(t => t.id)
            });
        } catch (error) {
            logger.error('Error getting available topics', {
                error: error.message
            });
        }
        
        try {
            const channel = await notificationsApi.postNotificationsChannels();
            logger.info('Created notification channel', { channelId: channel.id });
            
            // Opret WebSocket forbindelse
            const socket = new WebSocket(channel.connectUri);
            webSockets[connectionId] = socket;
            
            // Nulstil genoprettelsesforsøg når vi succesfuldt har forbundet
            reconnectionAttempts[connectionId] = 0;
            
            socket.on('open', async () => {
                logger.info('WebSocket connected', { connectionId });
                
                // Få fat i brugeroplysninger
                let userId = null;
                try {
                    const usersApi = new platformClient.UsersApi();
                    const me = await usersApi.getUsersMe();
                    userId = me.id;
                    logger.info('Got user ID for presence', { userId });
                } catch (error) {
                    logger.error('Error getting user info', { error: error.message });
                }
                
                // Definer emner med wildcards
                let topicsToUse = [
                    'v2.users.*.presence',
                    'v2.users.*.routingStatus'
                ];
                
                // Tilføj brugerspecifikt emne hvis vi har et userId
                if (userId) {
                    topicsToUse.push(`v2.users.${userId}.presence`);
                    topicsToUse.push(`v2.users.${userId}.routingStatus`);
                }
                
                logger.info('Using topics for subscription', { topics: topicsToUse });
                
                // Send en enkelt subscribe besked med alle emner
                const correlationId = `sub-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;
                socket.send(JSON.stringify({
                    message: "subscribe",
                    topics: topicsToUse,
                    correlationId: correlationId
                }));
                logger.info('Subscribed to topics with correlation ID', { 
                    topics: topicsToUse,
                    correlationId: correlationId
                });
                
                // Start heartbeat
                const heartbeatInterval = setInterval(() => {
                    if (socket.readyState === WebSocket.OPEN) {
                        logger.info('Sending heartbeat', { connectionId });
                        socket.send(JSON.stringify({ message: 'ping' }));
                    } else {
                        logger.warn('Socket not open for heartbeat', { 
                            connectionId,
                            state: socket.readyState
                        });
                        clearInterval(heartbeatInterval);
                    }
                }, 30000); // Hver 30. sekund
                
                // Sørg for at rydde op i intervallet ved lukning
                socket.on('close', () => {
                    clearInterval(heartbeatInterval);
                });
                
                // Tjek aktive abonnementer efter en kort forsinkelse
                setTimeout(async () => {
                    try {
                        const subscriptions = await notificationsApi.getNotificationsChannelSubscriptions(channel.id);
                        logger.info('Active channel subscriptions', { 
                            channelId: channel.id,
                            count: subscriptions.entities.length,
                            topics: subscriptions.entities.map(s => s.id)
                        });
                        
                        if (subscriptions.entities.length === 0) {
                            // Prøv at abonnere via REST API hvis WebSocket subscribe fejlede
                            try {
                                logger.info('No subscriptions found, trying REST API');
                                await notificationsApi.postNotificationsChannelSubscriptions(channel.id, 
                                    topicsToUse.map(topic => ({ id: topic }))
                                );
                                logger.info('Subscribed via REST API successfully');
                                
                                // Tjek igen om abonnementerne blev oprettet
                                const updatedSubscriptions = await notificationsApi.getNotificationsChannelSubscriptions(channel.id);
                                logger.info('Updated subscriptions after REST API', {
                                    count: updatedSubscriptions.entities.length,
                                    topics: updatedSubscriptions.entities.map(s => s.id)
                                });
                            } catch (subError) {
                                logger.error('Error subscribing via REST API', { error: subError.message });
                            }
                        }
                    } catch (error) {
                        logger.error('Error checking subscriptions', { error: error.message });
                    }
                }, 5000);
                
                // Automatisk test af presence-ændringer
                if (userId) {
                    setTimeout(async () => {
                        try {
                            // Forsøg at generere en notifikation ved at opdatere vores egen presence
                            const presenceApi = new platformClient.PresenceApi();
                            const presenceList = await presenceApi.getPresencedefinitions();
                            
                            if (presenceList.entities && presenceList.entities.length > 0) {
                                logger.info('Found presence definitions', {
                                    count: presenceList.entities.length,
                                    first: presenceList.entities[0].systemPresence
                                });
                                
                                // Find en presence definition at skifte til (vælg en der er anderledes end den nuværende)
                                const currentPresence = await presenceApi.getUserPresence(userId, 'PURECLOUD');
                                const currentSystemPresence = currentPresence.presenceDefinition.systemPresence;
                                
                                logger.info('Current presence', { systemPresence: currentSystemPresence });
                                
                                const targetPresence = currentSystemPresence === 'AVAILABLE' ? 
                                    presenceList.entities.find(p => p.systemPresence === 'AWAY') : 
                                    presenceList.entities.find(p => p.systemPresence === 'AVAILABLE');
                                
                                if (targetPresence) {
                                    logger.info('Attempting to change presence to trigger notification', {
                                        from: currentSystemPresence,
                                        to: targetPresence.systemPresence,
                                        presenceId: targetPresence.id
                                    });
                                    
                                    await presenceApi.patchUserPresence(userId, 'PURECLOUD', {
                                        presenceDefinition: { id: targetPresence.id }
                                    });
                                    
                                    logger.info('Presence changed successfully');
                                } else {
                                    logger.warn('Could not find suitable presence to change to');
                                }
                            }
                        } catch (error) {
                            logger.error('Error testing presence change', { error: error.message });
                        }
                    }, 10000);
                }
            });

            socket.on('message', (data) => {
                try {
                    // Log rådata for debugging
                    const rawData = data.toString();
                    logger.info('Raw WebSocket message received', { 
                        preview: rawData.substring(0, 150) 
                    });
                    
                    const message = JSON.parse(rawData);
                    
                    // Log alle indgående beskeder
                    logger.info('Received WebSocket message', { 
                        topicName: message.topicName || 'unknown',
                        hasEventBody: !!message.eventBody
                    });
                    
                    // Tjek om det er en abonnementsfejl
                    if (message.status === 'error') {
                        logger.error('Subscription error', {
                            status: message.status,
                            result: message.result,
                            message: message.message,
                            topics: message.topics
                        });
                    }
                    
                    // Tjek om det er en vellykket abonnement
                    if (message.status === 'subscribed') {
                        logger.info('Successfully subscribed to topics', {
                            topics: message.topics,
                            correlationId: message.correlationId
                        });
                    }
                    
                    // Specifik håndtering af heartbeat-svar
                    if (message.topicName === "channel.metadata" && message.eventBody && message.eventBody.message === "pong") {
                        logger.info('Received heartbeat response', { connectionId });
                        return;
                    }
                    
                    // Hvis det er en notifikation (ikke metadata)
                    if (message.eventBody) {
                        const notification = {
                            timestamp: new Date(),
                            topic: message.topicName,
                            data: message.eventBody
                        };
                        
                        // Log den faktiske notification
                        logger.info('Received notification', {
                            topic: message.topicName,
                            content: JSON.stringify(message.eventBody).substring(0, 100) + '...'
                        });
                        
                        // Tilføj til notifikationer
                        notifications[connectionId].unshift(notification);
                        
                        // Begræns antal notifikationer
                        if (notifications[connectionId].length > 100) {
                            notifications[connectionId] = notifications[connectionId].slice(0, 100);
                        }
                    }
                } catch (error) {
                    logger.error('Error processing WebSocket message', { 
                        error: error.message,
                        rawData: typeof data === 'string' ? data.substring(0, 100) : 'non-string data'
                    });
                }
            });
            
            socket.on('error', (error) => {
                logger.error('WebSocket error', { 
                    connectionId, 
                    error: error.message 
                });
            });
            
            socket.on('close', () => {
                logger.info('WebSocket closed', { connectionId });
                // Forsøg at genoprette forbindelsen
                reconnectWebSocket(connectionId);
            });
            
            // Tilføj ikke test notifikation her, når vi har en reel forbindelse
            // Vi vil kun se rigtige notifikationer
            
        } catch (error) {
            logger.error('Error creating notification channel', { 
                error: error.message,
                connectionId
            });
            
            // Tilføj test notifikation i tilfælde af fejl
            addTestNotification(connectionId);
        }
        
    } catch (error) {
        logger.error('Error setting up Genesys Cloud client', { 
            error: error.message,
            connectionId
        });
        
        // Tilføj test notifikation i tilfælde af fejl
        addTestNotification(connectionId);
    }

    return Promise.resolve();
}

// Funktion til at forsøge at genoprette forbindelsen
function reconnectWebSocket(connectionId) {
    if (!clientConnections[connectionId]) {
        logger.info('Connection no longer exists, not reconnecting', { connectionId });
        return;
    }
    
    // Begræns antal genoprettelsesforsøg
    if (!reconnectionAttempts[connectionId]) {
        reconnectionAttempts[connectionId] = 0;
    }
    
    reconnectionAttempts[connectionId]++;
    
    if (reconnectionAttempts[connectionId] > 5) {
        logger.error('Too many reconnection attempts, giving up', { connectionId });
        return;
    }
    
    // Forsøg at genoprette forbindelsen efter en kort forsinkelse
    logger.info('Attempting to reconnect WebSocket', { 
        connectionId, 
        attempt: reconnectionAttempts[connectionId] 
    });
    
    setTimeout(() => {
        try {
            connectToGenesys(connectionId, clientConnections[connectionId].topics);
        } catch (error) {
            logger.error('Reconnection attempt failed', { 
                connectionId, 
                error: error.message 
            });
        }
    }, 5000 * reconnectionAttempts[connectionId]); // Progressiv ventetid
}

function addTestNotification(connectionId) {
    const testNotification = {
        timestamp: new Date(),
        topic: 'v2.notifications.user.presence',
        data: {
            id: 'test-user',
            name: 'Test User',
            presenceDefinition: {
                systemPresence: 'AVAILABLE',
                presenceMessage: 'Available'
            },
            modifiedDate: new Date().toISOString()
        }
    };
    
    notifications[connectionId].unshift(testNotification);
    logger.info('Added test notification', { connectionId });
}

function disconnectFromGenesys(connectionId) {
    logger.info('Disconnecting from Genesys Cloud', { connectionId });

    // Luk websocket hvis den findes
    if (webSockets[connectionId]) {
        try {
            webSockets[connectionId].close();
        } catch (e) {
            logger.error('Error closing websocket', { error: e.message });
        }
        delete webSockets[connectionId];
    }

    // Fjern forbindelse og notifikationer
    if (clientConnections[connectionId]) {
        delete clientConnections[connectionId];
        delete notifications[connectionId];
    }
    
    // Nulstil genoprettelsesforsøg
    delete reconnectionAttempts[connectionId];
}

function getActiveNotifications() {
    return Object.keys(clientConnections).map(id => ({
        id,
        name: clientConnections[id].name,
        topics: clientConnections[id].topics
    }));
}

function getNotifications(connectionId) {
    logger.info('Getting notifications for connection', { 
        connectionId,
        count: notifications[connectionId] ? notifications[connectionId].length : 0
    });
    
    // Returner notifikationer eller tom array
    return notifications[connectionId] || [];
}

module.exports = {
    connectToGenesys,
    disconnectFromGenesys,
    getActiveNotifications,
    getNotifications
};